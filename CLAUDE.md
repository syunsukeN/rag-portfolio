# CLAUDE.md

このファイルは、Claude Code (claude.ai/code) がこのリポジトリで作業する際のガイダンスを提供します。

## プロジェクト概要

RAG（Retrieval-Augmented Generation）ベースの社内資料検索・質問応答システムです。ベクトルストレージにChromaDB、埋め込みとLLMにGemini、バックエンドAPIにFastAPIを使用しています。

**主要な設計思想:**
- AIの回答は保存されたドキュメントの情報のみに制限
- すべての回答に参照元ドキュメントを明示して透明性を確保
- ナレッジベースに存在しない質問には明示的に回答を拒否

## 必須コマンド

### 環境構築
```bash
# 仮想環境の作成と有効化
python3 -m venv venv
source venv/bin/activate

# 依存ライブラリのインストール
pip3 install -r requirements.txt

# 環境変数の設定
cp .env.example .env
# .envを編集してCHROMA_GOOGLE_GENAI_API_KEYを設定
```

### データベース操作
```bash
# data/docs/のドキュメントでベクトルデータベースを初期化・更新
python3 setup_db.py
```

### アプリケーション実行
```bash
# ホットリロード付きでFastAPIサーバーを起動
python3 -m uvicorn main:app --reload

# フロントエンドへのアクセス: ブラウザでfrontend/index.htmlを開く
```

## アーキテクチャ

### コアコンポーネント

**バックエンド ([main.py](main.py)):**
- フロントエンド通信のためCORSを有効化したFastAPIサーバー
- `./chroma_db`に永続化するChromaDBクライアント
- 埋め込みとLLM応答の両方にGemini APIを統合
- コレクション名: `company_docs`

**データベースセットアップ ([setup_db.py](setup_db.py)):**
- [data/docs/](data/docs/)からMarkdownドキュメントを読み込み
- ベクトル化にGemini `text-embedding-004`を使用
- メタデータ（ファイル名）と共にChromaDBにベクトルを保存
- 各ドキュメントは単一のベクトルとして保存（チャンク分割なし）

**フロントエンド ([frontend/index.html](frontend/index.html)):**
- スタンドアロンのHTML/CSS/JavaScriptインターフェース
- fetch APIでバックエンドと通信
- ビルドプロセス不要

### データフロー

1. **ドキュメント取り込み:** `setup_db.py` → `.md`ファイル読み込み → Gemini Embedding → ChromaDB
2. **質問処理:** ユーザーの質問 → `/ask`エンドポイント → ChromaDBクエリ（上位2件） → Gemini LLM → 参照元付き回答
3. **検索のみ:** `/search`エンドポイントはLLM処理なしで生のドキュメントチャンクを返却

### APIエンドポイント

- `POST /ask` - メインのRAGエンドポイント（クエリ + LLM応答）
  - リクエスト: `{"text": "質問内容"}`
  - レスポンス: `{"question": str, "answer": str, "sources": [str]}`
- `POST /search` - ベクトル検索のみ（LLMなし）
  - 上位2件のドキュメントを距離スコアと共に返却
- `GET /health` - ヘルスチェック
- `GET /` - ルートエンドポイント

### 主要な設定

**埋め込みモデル:** `models/text-embedding-004` (Gemini)
**LLMモデル:** `models/gemini-2.5-flash-preview-09-2025`
**Temperature:** 0.3（精度重視のため低く設定）
**取得件数:** 上位2件（n_results=2）

### プロンプトエンジニアリング

システムは厳格なシステムプロンプト（[main.py:89-95](main.py#L89-L95)）を使用:
1. 提供されたドキュメントのみに回答を制限
2. 情報が利用できない場合は明示的に表明を要求
3. 参照元の引用を義務化
4. 簡潔で箇条書き形式の回答を強制

## 環境変数

`.env`で必須:
- `CHROMA_GOOGLE_GENAI_API_KEY` - 埋め込みと生成の両方に使用するGoogle AI APIキー

## 重要な注意事項

- ドキュメントはチャンク分割なしで完全なファイルとして保存されるため、大きなドキュメントでは検索品質が制限される可能性があります
- ChromaDBは`./chroma_db/`に永続化されます（gitignore対象）
- CORSは現在`allow_origins=["*"]`に設定されています - 本番環境では制限してください
- フロントエンドはデフォルトで`http://localhost:8000`にリクエストを送信します
- [data/docs/](data/docs/)のドキュメントを追加・変更した後は`setup_db.py`を再実行してください

## 開発者向け指示

**ユーザーはAIエンジニアを目指して勉強中のため、以下を必ず守ること:**

1. **実装完了後の解説**: 機能実装が完了したら、初学者向けに以下を説明する
   - なぜその技術・ライブラリを選んだのか
   - コードがどのように動作するのか（処理の流れ）
   - 重要な概念や用語の説明
   - 実務での応用例やベストプラクティス

2. **コメントの追加**: コードには最低限わかりやすい日本語コメントを追加する
   - 各関数・クラスの役割
   - 複雑な処理の流れ
   - なぜその実装にしたのかの理由（必要に応じて）

## 実務品質チェックリスト

機能実装時は以下5点を確認すること:

| 観点 | 確認内容 |
|------|----------|
| 再現性 | 誰が実行しても同じ結果になるか |
| 説明可能性 | なぜその実装にしたか説明できるか |
| 堅牢性 | 更新・例外・運用に耐えるか |
| 停止可能性 | 危険な入力・状況で適切に止まるか |
| 改善可能性 | ログから問題を特定し改善できるか |

## 段階的拡張ロードマップ

このプロジェクトを実務レベルに引き上げるためのフェーズ:

### Phase 1: 制御強化（基本品質）
- [x] 根拠表示（参照ドキュメント名を回答に含める）
- [x] 非回答ルール（資料にない情報は答えない）
- [ ] 追加質問フロー（根拠が弱い時に「もう少し詳しく教えてください」を返す）
- [ ] 検索スコア閾値（信頼度の低い検索結果を除外）

### Phase 2: 計測（品質の可視化）
- [ ] 評価用質問セット作成（20-30問、正解の参照文書を紐づけ）
- [ ] Recall@k の計測スクリプト実装
- [ ] 失敗ケースの分類と記録

### Phase 3: 運用（継続的改善）
- [ ] フィードバックボタン（「この回答は違う」）
- [ ] リクエスト/レスポンスのログ保存
- [ ] 失敗ログからの改善タスク化フロー

### Phase 4: 企業導入レベル
- [ ] アクセス制御（部署・権限による閲覧制限）
- [ ] 禁止質問フィルタ（機密・人事・給与など）
- [ ] 監査ログ（誰が何を聞いたかの記録）

## 機能開発テンプレート

新機能を実装する際は、以下7項目を明確にしてから着手すること:

1. **目的**: この機能の業務上の価値は何か
2. **制約**: 機密情報、速度要件、コスト、禁止事項
3. **入出力**: 入力形式と出力形式（JSON例を含む）
4. **失敗要件**: どんな時に答えないか、エラー時の挙動
5. **テスト観点**: 境界値、例外ケース、回帰テスト
6. **運用**: ログ項目、監視方法、ロールバック手順
7. **変更容易性**: 設定ファイル化、差分更新の容易さ

## 実務成果物チェックリスト

ポートフォリオとして評価されるために、以下のドキュメントを用意すること:

- [ ] **アーキテクチャ図**（システム構成を1枚で説明）
- [ ] **用途定義書**（使っていい用途/ダメな用途を明記）
- [ ] **失敗例集**（想定される失敗パターンと対処法 10個以上）
- [ ] **評価方法**（質問セットと評価指標の定義）
- [ ] **運用手順書**（起動・停止・更新・障害対応の手順）
